<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interview - AI Interview Platform</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #64748b;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --dark-color: #1e293b;
            --light-color: #f8fafc;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--dark-color);
        }

        .interview-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            margin: 2rem auto;
            max-width: 900px;
            overflow: hidden;
            position: relative;
        }

        .interview-header {
            background: linear-gradient(135deg, var(--primary-color), #3b82f6);
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .progress-container {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            height: 8px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .progress-bar {
            background: white;
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .timer-display {
            font-size: 1.2rem;
            font-weight: 600;
            margin-top: 1rem;
        }

        .question-section {
            padding: 3rem;
            min-height: 400px;
        }

        .question-card {
            background: var(--light-color);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border-left: 5px solid var(--primary-color);
        }

        .question-text {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--dark-color);
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }

        .answer-section {
            margin-top: 2rem;
        }

        .answer-textarea {
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 1rem;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            min-height: 150px;
            resize: vertical;
        }

        .answer-textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            outline: none;
        }

        .speech-controls {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
            align-items: center;
            flex-wrap: wrap;
        }

        .speech-btn {
            background: var(--success-color);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 0.8rem 1.5rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .speech-btn:hover {
            background: #059669;
            transform: translateY(-2px);
        }

        .speech-btn.recording {
            background: var(--danger-color);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .speech-status {
            font-size: 0.9rem;
            color: var(--secondary-color);
            font-style: italic;
        }

        .interview-controls {
            background: var(--light-color);
            padding: 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .control-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .btn-primary-custom {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 0.8rem 2rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary-custom:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
        }

        .btn-secondary-custom {
            background: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 0.8rem 1.5rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-secondary-custom:hover {
            background: #475569;
        }

        .btn-warning-custom {
            background: var(--warning-color);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 0.8rem 1.5rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-warning-custom:hover {
            background: #d97706;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loading-spinner {
            background: white;
            padding: 2rem;
            border-radius: 15px;
            text-align: center;
        }

        .spinner-border {
            color: var(--primary-color);
        }

        .error-message {
            background: #fee2e2;
            color: #dc2626;
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
            border-left: 4px solid #dc2626;
        }

        .success-message {
            background: #d1fae5;
            color: #065f46;
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
            border-left: 4px solid #10b981;
        }

        .interview-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .stat-card {
            background: white;
            padding: 1.5rem;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .stat-label {
            color: var(--secondary-color);
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .pause-content {
            background: white;
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
        }

        .feedback-section {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .feedback-text {
            color: var(--dark-color);
            line-height: 1.6;
        }

        .score-badge {
            background: var(--success-color);
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .accessibility-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 1rem;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .font-size-controls button {
            margin: 0 0.2rem;
            padding: 0.3rem 0.6rem;
            border: 1px solid var(--secondary-color);
            background: white;
            border-radius: 5px;
            cursor: pointer;
        }

        .high-contrast {
            filter: contrast(150%);
        }

        .large-text {
            font-size: 1.2em;
        }

        .extra-large-text {
            font-size: 1.4em;
        }

        .api-key-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .api-key-content {
            background: white;
            padding: 2rem;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
        }

        .api-key-input {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .api-key-input:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        @media (max-width: 768px) {
            .interview-container {
                margin: 1rem;
                border-radius: 15px;
            }

            .question-section {
                padding: 2rem 1.5rem;
            }

            .interview-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: center;
            }

            .interview-stats {
                grid-template-columns: 1fr;
            }

            .speech-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }

        .notification-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification-toast.show {
            transform: translateX(0);
        }

        .language-selector {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }

        .language-selector select {
            padding: 0.5rem;
            border-radius: 5px;
            border: 1px solid var(--secondary-color);
            background: white;
        }

        .ai-thinking {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--primary-color);
            font-style: italic;
        }

        .thinking-dots {
            display: inline-flex;
            gap: 2px;
        }

        .thinking-dots span {
            width: 4px;
            height: 4px;
            background: var(--primary-color);
            border-radius: 50%;
            animation: thinking 1.4s infinite ease-in-out;
        }

        .thinking-dots span:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes thinking {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <!-- API Key Modal -->
    <div id="apiKeyModal" class="api-key-modal">
        <div class="api-key-content">
            <h3 data-translate="api_key_required">Gemini API Key Required</h3>
            <p data-translate="api_key_description">Please enter your Google Gemini API key to enable AI-powered feedback and scoring.</p>
            <input type="password" id="apiKeyInput" class="api-key-input" placeholder="Enter your Gemini API key..." data-translate-placeholder="api_key_placeholder">
            <div class="d-flex gap-2 mt-3">
                <button class="btn-primary-custom flex-fill" onclick="saveApiKey()">
                    <i class="fas fa-save"></i>
                    <span data-translate="save">Save</span>
                </button>
                <button class="btn-secondary-custom" onclick="skipApiKey()">
                    <span data-translate="skip">Skip</span>
                </button>
            </div>
            <small class="text-muted d-block mt-2" data-translate="api_key_note">
                Your API key is stored locally and never shared. Get your key from Google AI Studio.
            </small>
        </div>
    </div>

    <!-- Language Selector -->
    <div class="language-selector">
        <select id="languageSelect" onchange="changeLanguage(this.value)">
            <option value="en">English</option>
            <option value="es">Español</option>
            <option value="fr">Français</option>
            <option value="de">Deutsch</option>
        </select>
    </div>

    <!-- Accessibility Controls -->
    <div class="accessibility-controls">
        <div class="font-size-controls">
            <button onclick="changeFontSize('normal')" title="Normal text size">A</button>
            <button onclick="changeFontSize('large')" title="Large text size">A+</button>
            <button onclick="changeFontSize('extra-large')" title="Extra large text size">A++</button>
        </div>
        <button onclick="toggleHighContrast()" class="btn btn-sm btn-outline-secondary mt-2" title="Toggle high contrast">
            <i class="fas fa-adjust"></i> Contrast
        </button>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-3" data-translate="loading">Loading interview...</p>
        </div>
    </div>

    <!-- Main Interview Container -->
    <div class="container-fluid">
        <div class="interview-container" id="interviewContainer">
            <!-- Interview Header -->
            <div class="interview-header">
                <h1 id="interviewTitle" data-translate="interview_title">Technical Interview</h1>
                <div class="interview-stats">
                    <div class="stat-card">
                        <div class="stat-number" id="currentQuestionNum">1</div>
                        <div class="stat-label" data-translate="current_question">Current Question</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="totalQuestions">0</div>
                        <div class="stat-label" data-translate="total_questions">Total Questions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="timeElapsed">00:00</div>
                        <div class="stat-label" data-translate="time_elapsed">Time Elapsed</div>
                    </div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                </div>
            </div>

            <!-- Question Section -->
            <div class="question-section">
                <div id="errorMessage" class="error-message" style="display: none;"></div>
                <div id="successMessage" class="success-message" style="display: none;"></div>

                <div class="question-card">
                    <div class="question-text" id="questionText" data-translate="loading_question">
                        Loading question...
                    </div>
                    
                    <div class="answer-section">
                        <label for="answerTextarea" class="form-label" data-translate="your_answer">Your Answer:</label>
                        <textarea 
                            id="answerTextarea" 
                            class="form-control answer-textarea" 
                            placeholder="Type your answer here or use speech-to-text..."
                            data-translate-placeholder="answer_placeholder"
                        ></textarea>
                        
                        <div class="speech-controls">
                            <button id="speechBtn" class="speech-btn" onclick="toggleSpeechRecognition()">
                                <i class="fas fa-microphone"></i>
                                <span data-translate="start_recording">Start Recording</span>
                            </button>
                            <div class="speech-status" id="speechStatus" data-translate="speech_ready">
                                Speech recognition ready
                            </div>
                        </div>
                    </div>

                    <div id="feedbackSection" class="feedback-section" style="display: none;">
                        <h5 data-translate="ai_feedback">AI Feedback:</h5>
                        <div id="aiThinking" class="ai-thinking" style="display: none;">
                            <i class="fas fa-brain"></i>
                            <span data-translate="ai_thinking">AI is analyzing your answer</span>
                            <div class="thinking-dots">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                        <div id="feedbackText" class="feedback-text"></div>
                        <div class="mt-2">
                            <span data-translate="score">Score: </span>
                            <span id="questionScore" class="score-badge">0/10</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Interview Controls -->
            <div class="interview-controls">
                <div class="control-group">
                    <button id="pauseBtn" class="btn-secondary-custom" onclick="pauseInterview()">
                        <i class="fas fa-pause"></i>
                        <span data-translate="pause">Pause</span>
                    </button>
                    <button id="skipBtn" class="btn-warning-custom" onclick="skipQuestion()">
                        <i class="fas fa-forward"></i>
                        <span data-translate="skip">Skip</span>
                    </button>
                </div>
                
                <div class="control-group">
                    <button id="nextBtn" class="btn-primary-custom" onclick="nextQuestion()" disabled>
                        <span data-translate="next_question">Next Question</span>
                        <i class="fas fa-arrow-right"></i>
                    </button>
                </div>
            </div>

            <!-- Pause Overlay -->
            <div id="pauseOverlay" class="pause-overlay" style="display: none;">
                <div class="pause-content">
                    <h3 data-translate="interview_paused">Interview Paused</h3>
                    <p data-translate="pause_message">Take your time. Click resume when you're ready to continue.</p>
                    <button class="btn-primary-custom" onclick="resumeInterview()">
                        <i class="fas fa-play"></i>
                        <span data-translate="resume">Resume</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification Toast -->
    <div id="notificationToast" class="notification-toast">
        <span id="toastMessage"></span>
    </div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics-compat.js"></script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCVYdfql5aqHrChlA1v3nxRLkIbYyWMvUg",
            authDomain: "study2-7bdc7.firebaseapp.com",
            databaseURL: "https://study2-7bdc7-default-rtdb.firebaseio.com",
            projectId: "study2-7bdc7",
            storageBucket: "study2-7bdc7.firebasestorage.app",
            messagingSenderId: "320617984870",
            appId: "1:320617984870:web:04b61ea4ee88ae057e4ea7",
            measurementId: "G-VRM14GRNWG"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const analytics = firebase.analytics();

        // Global Variables
        let currentUser = null;
        let interviewId = null;
        let interviewData = null;
        let templateData = null;
        let currentQuestionIndex = 0;
        let questions = [];
        let startTime = null;
        let timerInterval = null;
        let isPaused = false;
        let speechRecognition = null;
        let isRecording = false;
        let currentLanguage = 'en';
        let geminiApiKey = null;

        // Internationalization
        const translations = {
            en: {
                interview_title: "Technical Interview",
                current_question: "Current Question",
                total_questions: "Total Questions",
                time_elapsed: "Time Elapsed",
                loading_question: "Loading question...",
                your_answer: "Your Answer:",
                answer_placeholder: "Type your answer here or use speech-to-text...",
                start_recording: "Start Recording",
                stop_recording: "Stop Recording",
                speech_ready: "Speech recognition ready",
                speech_listening: "Listening...",
                speech_processing: "Processing...",
                ai_feedback: "AI Feedback:",
                ai_thinking: "AI is analyzing your answer",
                score: "Score:",
                pause: "Pause",
                skip: "Skip",
                next_question: "Next Question",
                interview_paused: "Interview Paused",
                pause_message: "Take your time. Click resume when you're ready to continue.",
                resume: "Resume",
                loading: "Loading interview...",
                interview_completed: "Interview Completed!",
                generating_results: "Generating final results...",
                error_no_interview: "Interview not found",
                error_no_template: "Interview template not found",
                error_auth: "Authentication required",
                error_speech: "Speech recognition not supported",
                error_api_key: "Gemini API key is required for AI feedback",
                success_answer_saved: "Answer saved successfully",
                notification_time_warning: "You have 5 minutes remaining",
                notification_question_skipped: "Question skipped",
                api_key_required: "Gemini API Key Required",
                api_key_description: "Please enter your Google Gemini API key to enable AI-powered feedback and scoring.",
                api_key_placeholder: "Enter your Gemini API key...",
                api_key_note: "Your API key is stored locally and never shared. Get your key from Google AI Studio.",
                save: "Save",
                skip: "Skip"
            },
            es: {
                interview_title: "Entrevista Técnica",
                current_question: "Pregunta Actual",
                total_questions: "Total de Preguntas",
                time_elapsed: "Tiempo Transcurrido",
                loading_question: "Cargando pregunta...",
                your_answer: "Tu Respuesta:",
                answer_placeholder: "Escribe tu respuesta aquí o usa voz a texto...",
                start_recording: "Iniciar Grabación",
                stop_recording: "Detener Grabación",
                speech_ready: "Reconocimiento de voz listo",
                speech_listening: "Escuchando...",
                speech_processing: "Procesando...",
                ai_feedback: "Retroalimentación IA:",
                ai_thinking: "La IA está analizando tu respuesta",
                score: "Puntuación:",
                pause: "Pausar",
                skip: "Saltar",
                next_question: "Siguiente Pregunta",
                interview_paused: "Entrevista Pausada",
                pause_message: "Tómate tu tiempo. Haz clic en reanudar cuando estés listo para continuar.",
                resume: "Reanudar",
                loading: "Cargando entrevista...",
                interview_completed: "¡Entrevista Completada!",
                generating_results: "Generando resultados finales...",
                error_no_interview: "Entrevista no encontrada",
                error_no_template: "Plantilla de entrevista no encontrada",
                error_auth: "Autenticación requerida",
                error_speech: "Reconocimiento de voz no soportado",
                error_api_key: "Se requiere la clave API de Gemini para retroalimentación IA",
                success_answer_saved: "Respuesta guardada exitosamente",
                notification_time_warning: "Te quedan 5 minutos",
                notification_question_skipped: "Pregunta saltada",
                api_key_required: "Clave API de Gemini Requerida",
                api_key_description: "Por favor ingresa tu clave API de Google Gemini para habilitar retroalimentación y puntuación con IA.",
                api_key_placeholder: "Ingresa tu clave API de Gemini...",
                api_key_note: "Tu clave API se almacena localmente y nunca se comparte. Obtén tu clave de Google AI Studio.",
                save: "Guardar",
                skip: "Saltar"
            }
        };

        // Utility Functions
        function getTranslation(key) {
            return translations[currentLanguage][key] || translations.en[key] || key;
        }

        function updateTranslations() {
            document.querySelectorAll('[data-translate]').forEach(element => {
                const key = element.getAttribute('data-translate');
                element.textContent = getTranslation(key);
            });

            document.querySelectorAll('[data-translate-placeholder]').forEach(element => {
                const key = element.getAttribute('data-translate-placeholder');
                element.placeholder = getTranslation(key);
            });
        }

        function changeLanguage(lang) {
            currentLanguage = lang;
            updateTranslations();
            
            // Update speech recognition language
            if (speechRecognition) {
                speechRecognition.lang = lang === 'es' ? 'es-ES' : 'en-US';
            }
        }

        function showLoading(show = true) {
            document.getElementById('loadingOverlay').style.display = show ? 'flex' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.getElementById('successMessage');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => {
                successDiv.style.display = 'none';
            }, 3000);
        }

        function showNotification(message) {
            const toast = document.getElementById('notificationToast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
        }

        function logAction(action, data = {}) {
            const logData = {
                timestamp: new Date().toISOString(),
                userId: currentUser?.uid,
                interviewId: interviewId,
                action: action,
                data: data,
                userAgent: navigator.userAgent,
                url: window.location.href
            };
            
            console.log('Action Log:', logData);
            
            // Store in Firestore for auditing
            if (currentUser && interviewId) {
                db.collection('users')
                    .doc(currentUser.uid)
                    .collection('interviews')
                    .doc(interviewId)
                    .collection('logs')
                    .add(logData)
                    .catch(error => console.error('Error logging action:', error));
            }
            
            // Send to analytics
            analytics.logEvent('interview_action', {
                action: action,
                interview_id: interviewId,
                question_index: currentQuestionIndex
            });
        }

        // API Key Management
        function showApiKeyModal() {
            document.getElementById('apiKeyModal').style.display = 'flex';
        }

        function hideApiKeyModal() {
            document.getElementById('apiKeyModal').style.display = 'none';
        }

        function saveApiKey() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (apiKey) {
                geminiApiKey = apiKey;
                localStorage.setItem('gemini_api_key', apiKey);
                hideApiKeyModal();
                logAction('api_key_saved');
            } else {
                showError('Please enter a valid API key');
            }
        }

        function skipApiKey() {
            hideApiKeyModal();
            showNotification('AI feedback will be disabled without API key');
            logAction('api_key_skipped');
        }

        function loadApiKey() {
            const savedKey = localStorage.getItem('gemini_api_key');
            if (savedKey) {
                geminiApiKey = savedKey;
                return true;
            }
            return false;
        }

        // Accessibility Functions
        function changeFontSize(size) {
            document.body.classList.remove('large-text', 'extra-large-text');
            if (size === 'large') {
                document.body.classList.add('large-text');
            } else if (size === 'extra-large') {
                document.body.classList.add('extra-large-text');
            }
            logAction('accessibility_font_change', { size });
        }

        function toggleHighContrast() {
            document.body.classList.toggle('high-contrast');
            logAction('accessibility_contrast_toggle');
        }

        // Timer Functions
        function startTimer() {
            startTime = new Date();
            timerInterval = setInterval(updateTimer, 1000);
            logAction('timer_started');
        }

        function updateTimer() {
            if (isPaused) return;
            
            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            document.getElementById('timeElapsed').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Warning at 25 minutes (5 minutes remaining for 30-minute interview)
            if (elapsed === 1500) {
                showNotification(getTranslation('notification_time_warning'));
            }
        }

        function pauseTimer() {
            isPaused = true;
            logAction('timer_paused');
        }

        function resumeTimer() {
            isPaused = false;
            logAction('timer_resumed');
        }

        // Speech Recognition Functions
        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                speechRecognition = new SpeechRecognition();
                
                speechRecognition.continuous = true;
                speechRecognition.interimResults = true;
                speechRecognition.lang = currentLanguage === 'es' ? 'es-ES' : 'en-US';
                speechRecognition.maxAlternatives = 1;
                
                speechRecognition.onstart = function() {
                    isRecording = true;
                    updateSpeechButton();
                    document.getElementById('speechStatus').textContent = getTranslation('speech_listening');
                    logAction('speech_start');
                };
                
                speechRecognition.onresult = function(event) {
                    let finalTranscript = '';
                    let interimTranscript = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }
                    
                    const textarea = document.getElementById('answerTextarea');
                    if (finalTranscript) {
                        // Append to existing text with proper spacing
                        const currentText = textarea.value;
                        const newText = currentText + (currentText ? ' ' : '') + finalTranscript;
                        textarea.value = newText;
                        enableNextButton();
                        logAction('speech_text_added', { text: finalTranscript });
                    }
                };
                
                speechRecognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    isRecording = false;
                    updateSpeechButton();
                    document.getElementById('speechStatus').textContent = getTranslation('speech_ready');
                    showError('Speech recognition error: ' + event.error);
                    logAction('speech_error', { error: event.error });
                };
                
                speechRecognition.onend = function() {
                    isRecording = false;
                    updateSpeechButton();
                    document.getElementById('speechStatus').textContent = getTranslation('speech_ready');
                    logAction('speech_end');
                };
            } else {
                showError(getTranslation('error_speech'));
                document.querySelector('.speech-controls').style.display = 'none';
            }
        }

        function toggleSpeechRecognition() {
            if (!speechRecognition) {
                initializeSpeechRecognition();
                return;
            }
            
            if (isRecording) {
                speechRecognition.stop();
            } else {
                try {
                    speechRecognition.start();
                } catch (error) {
                    console.error('Error starting speech recognition:', error);
                    showError('Error starting speech recognition');
                }
            }
        }

        function updateSpeechButton() {
            const btn = document.getElementById('speechBtn');
            const icon = btn.querySelector('i');
            const text = btn.querySelector('span');
            
            if (isRecording) {
                btn.classList.add('recording');
                icon.className = 'fas fa-stop';
                text.textContent = getTranslation('stop_recording');
            } else {
                btn.classList.remove('recording');
                icon.className = 'fas fa-microphone';
                text.textContent = getTranslation('start_recording');
            }
        }

        // Interview Functions
        function getInterviewIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id');
        }

        async function loadInterview() {
            try {
                showLoading(true);
                
                interviewId = getInterviewIdFromUrl();
                if (!interviewId) {
                    throw new Error('Interview ID not found in URL');
                }
                
                // Fetch interview document
                const interviewDoc = await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('interviews')
                    .doc(interviewId)
                    .get();
                
                if (!interviewDoc.exists) {
                    throw new Error(getTranslation('error_no_interview'));
                }
                
                interviewData = interviewDoc.data();
                
                // Fetch template document
                if (!interviewData.templateId) {
                    window.location.href = 'error.html?message=no_template';
                    return;
                }
                
                const templateDoc = await db.collection('templates')
                    .doc(interviewData.templateId)
                    .get();
                
                if (!templateDoc.exists) {
                    throw new Error(getTranslation('error_no_template'));
                }
                
                templateData = templateDoc.data();
                questions = templateData.questions || [];
                
                // Update UI
                document.getElementById('interviewTitle').textContent = 
                    templateData.title || getTranslation('interview_title');
                document.getElementById('totalQuestions').textContent = questions.length;
                
                // Start interview
                startInterview();
                
            } catch (error) {
                console.error('Error loading interview:', error);
                showError(error.message);
                logAction('error_load_interview', { error: error.message });
            } finally {
                showLoading(false);
            }
        }

        function startInterview() {
            startTimer();
            displayCurrentQuestion();
            initializeSpeechRecognition();
            logAction('interview_start', { 
                templateId: templateData.id,
                totalQuestions: questions.length 
            });
        }

        function displayCurrentQuestion() {
            if (currentQuestionIndex >= questions.length) {
                completeInterview();
                return;
            }
            
            const question = questions[currentQuestionIndex];
            document.getElementById('questionText').textContent = question.questionText;
            document.getElementById('currentQuestionNum').textContent = currentQuestionIndex + 1;
            
            // Update progress bar
            const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
            
            // Clear previous answer and feedback
            document.getElementById('answerTextarea').value = '';
            document.getElementById('feedbackSection').style.display = 'none';
            document.getElementById('nextBtn').disabled = true;
            
            logAction('question_displayed', { 
                questionIndex: currentQuestionIndex,
                questionId: question.id,
                questionText: question.questionText
            });
        }

        function enableNextButton() {
            const answer = document.getElementById('answerTextarea').value.trim();
            document.getElementById('nextBtn').disabled = answer.length === 0;
        }

        async function nextQuestion() {
            try {
                showLoading(true);
                
                const answer = document.getElementById('answerTextarea').value.trim();
                if (!answer) {
                    showError('Please provide an answer before proceeding');
                    return;
                }
                
                await saveAnswer(answer);
                
                if (geminiApiKey) {
                    await generateFeedback(answer);
                } else {
                    showNotification('Skipping AI feedback - no API key provided');
                }
                
                currentQuestionIndex++;
                displayCurrentQuestion();
                
            } catch (error) {
                console.error('Error proceeding to next question:', error);
                showError('Error saving answer: ' + error.message);
                logAction('error_next_question', { error: error.message });
            } finally {
                showLoading(false);
            }
        }

        async function saveAnswer(answer) {
            const question = questions[currentQuestionIndex];
            const questionData = {
                questionId: question.id,
                questionText: question.questionText,
                expectedAnswer: question.expectedAnswer || '',
                userAnswer: answer,
                feedback: '',
                score: 0,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                wordCount: answer.split(/\s+/).length,
                characterCount: answer.length
            };
            
            await db.collection('users')
                .doc(currentUser.uid)
                .collection('interviews')
                .doc(interviewId)
                .collection('questions')
                .add(questionData);
            
            showSuccess(getTranslation('success_answer_saved'));
            logAction('answer_saved', { 
                questionIndex: currentQuestionIndex,
                answerLength: answer.length,
                wordCount: questionData.wordCount
            });
        }

        async function generateFeedback(answer) {
            try {
                document.getElementById('aiThinking').style.display = 'flex';
                document.getElementById('feedbackSection').style.display = 'block';
                
                const question = questions[currentQuestionIndex];
                
                const feedback = await callGeminiAPI({
                    questionText: question.questionText,
                    expectedAnswer: question.expectedAnswer || '',
                    userAnswer: answer,
                    difficulty: question.difficulty || 'medium',
                    category: question.category || 'general'
                });
                
                // Update question document with feedback
                const questionDocs = await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('interviews')
                    .doc(interviewId)
                    .collection('questions')
                    .where('questionId', '==', question.id)
                    .get();
                
                if (!questionDocs.empty) {
                    const questionDoc = questionDocs.docs[0];
                    await questionDoc.ref.update({
                        feedback: feedback.feedback,
                        score: feedback.score,
                        aiProcessingTime: feedback.processingTime
                    });
                    
                    // Display feedback
                    displayFeedback(feedback.feedback, feedback.score);
                }
                
                logAction('feedback_generated', { 
                    questionIndex: currentQuestionIndex,
                    score: feedback.score,
                    processingTime: feedback.processingTime
                });
                
            } catch (error) {
                console.error('Error generating feedback:', error);
                showError('Error generating AI feedback: ' + error.message);
                logAction('error_generate_feedback', { error: error.message });
            } finally {
                document.getElementById('aiThinking').style.display = 'none';
            }
        }

        async function callGeminiAPI(data) {
            const startTime = Date.now();
            
            const prompt = `
You are an expert technical interviewer. Please evaluate the following interview response:

Question: ${data.questionText}
Expected Answer: ${data.expectedAnswer}
User's Answer: ${data.userAnswer}
Difficulty Level: ${data.difficulty}
Category: ${data.category}

Please provide:
1. Detailed feedback on the answer (2-3 sentences)
2. A score from 1-10 based on:
   - Technical accuracy (40%)
   - Completeness (30%)
   - Clarity of explanation (20%)
   - Problem-solving approach (10%)

Format your response as JSON:
{
  "feedback": "Your detailed feedback here",
  "score": 8
}

Be constructive and specific in your feedback. Highlight both strengths and areas for improvement.
            `;

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${geminiApiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: prompt
                        }]
                    }],
                    generationConfig: {
                        temperature: 0.7,
                        topK: 40,
                        topP: 0.95,
                        maxOutputTokens: 1024,
                    }
                })
            });

            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            const generatedText = result.candidates[0].content.parts[0].text;
            
            try {
                // Extract JSON from the response
                const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const parsedResult = JSON.parse(jsonMatch[0]);
                    return {
                        feedback: parsedResult.feedback,
                        score: Math.max(1, Math.min(10, parsedResult.score)),
                        processingTime: Date.now() - startTime
                    };
                } else {
                    throw new Error('Invalid JSON response from Gemini');
                }
            } catch (parseError) {
                // Fallback if JSON parsing fails
                return {
                    feedback: generatedText.substring(0, 500) + '...',
                    score: 5,
                    processingTime: Date.now() - startTime
                };
            }
        }

        function displayFeedback(feedback, score) {
            document.getElementById('feedbackText').textContent = feedback;
            document.getElementById('questionScore').textContent = `${score}/10`;
            
            // Update score badge color based on score
            const scoreBadge = document.getElementById('questionScore');
            scoreBadge.className = 'score-badge';
            if (score >= 8) {
                scoreBadge.style.background = 'var(--success-color)';
            } else if (score >= 6) {
                scoreBadge.style.background = 'var(--warning-color)';
            } else {
                scoreBadge.style.background = 'var(--danger-color)';
            }
        }

        function skipQuestion() {
            if (confirm('Are you sure you want to skip this question? This will be recorded as a skipped question.')) {
                logAction('question_skipped', { 
                    questionIndex: currentQuestionIndex,
                    questionId: questions[currentQuestionIndex].id
                });
                showNotification(getTranslation('notification_question_skipped'));
                
                // Save empty answer for skipped question
                saveAnswer('[SKIPPED]').then(() => {
                    currentQuestionIndex++;
                    displayCurrentQuestion();
                });
            }
        }

        function pauseInterview() {
            pauseTimer();
            document.getElementById('pauseOverlay').style.display = 'flex';
            logAction('interview_paused', { 
                questionIndex: currentQuestionIndex,
                timeElapsed: document.getElementById('timeElapsed').textContent
            });
        }

        function resumeInterview() {
            resumeTimer();
            document.getElementById('pauseOverlay').style.display = 'none';
            logAction('interview_resumed', { 
                questionIndex: currentQuestionIndex
            });
        }

        async function completeInterview() {
            try {
                showLoading(true);
                
                // Calculate overall score
                const questionDocs = await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('interviews')
                    .doc(interviewId)
                    .collection('questions')
                    .get();
                
                let totalScore = 0;
                let questionCount = 0;
                let skippedCount = 0;
                
                questionDocs.forEach(doc => {
                    const data = doc.data();
                    if (data.userAnswer === '[SKIPPED]') {
                        skippedCount++;
                    } else if (data.score) {
                        totalScore += data.score;
                        questionCount++;
                    }
                });
                
                const overallScore = questionCount > 0 ? Math.round(totalScore / questionCount) : 0;
                const completionRate = ((questions.length - skippedCount) / questions.length) * 100;
                
                // Generate overall feedback
                const overallFeedback = await generateOverallFeedback(overallScore, completionRate, skippedCount);
                
                // Calculate duration
                const duration = Math.floor((new Date() - startTime) / 1000);
                
                // Update interview document
                await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('interviews')
                    .doc(interviewId)
                    .update({
                        status: 'completed',
                        score: overallScore,
                        overallFeedback: overallFeedback,
                        completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        duration: duration,
                        completionRate: completionRate,
                        skippedQuestions: skippedCount,
                        totalQuestions: questions.length
                    });
                
                logAction('interview_completed', { 
                    score: overallScore,
                    duration: duration,
                    completionRate: completionRate,
                    skippedQuestions: skippedCount,
                    totalQuestions: questions.length
                });
                
                // Redirect to results page
                window.location.href = `interview_results.html?id=${interviewId}`;
                
            } catch (error) {
                console.error('Error completing interview:', error);
                showError('Error completing interview: ' + error.message);
                logAction('error_complete_interview', { error: error.message });
            } finally {
                showLoading(false);
            }
        }

        async function generateOverallFeedback(score, completionRate, skippedCount) {
            if (geminiApiKey) {
                try {
                    const prompt = `
Generate overall interview feedback based on:
- Overall Score: ${score}/10
- Completion Rate: ${completionRate}%
- Questions Skipped: ${skippedCount}
- Total Questions: ${questions.length}
- Interview Type: ${templateData.title}

Provide constructive feedback in 2-3 sentences focusing on strengths and improvement areas.
                    `;

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${geminiApiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: prompt
                                }]
                            }],
                            generationConfig: {
                                temperature: 0.7,
                                maxOutputTokens: 512,
                            }
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        return result.candidates[0].content.parts[0].text;
                    }
                } catch (error) {
                    console.error('Error generating overall feedback:', error);
                }
            }
            
            // Fallback feedback
            if (score >= 8) {
                return "Excellent performance! You demonstrated strong technical knowledge and problem-solving skills throughout the interview.";
            } else if (score >= 6) {
                return "Good job! You showed solid understanding with room for improvement in some technical areas.";
            } else if (score >= 4) {
                return "Fair performance. Consider reviewing the topics covered and practicing more technical problems.";
            } else {
                return "There's significant room for improvement. Focus on strengthening your technical fundamentals and practice more.";
            }
        }

        // Event Listeners
        document.getElementById('answerTextarea').addEventListener('input', enableNextButton);

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'Enter':
                        e.preventDefault();
                        if (!document.getElementById('nextBtn').disabled) {
                            nextQuestion();
                        }
                        break;
                    case ' ':
                        e.preventDefault();
                        if (isPaused) {
                            resumeInterview();
                        } else {
                            pauseInterview();
                        }
                        break;
                    case 'm':
                        e.preventDefault();
                        toggleSpeechRecognition();
                        break;
                }
            }
        });

        // Authentication Check
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                currentUser = user;
                
                // Check for API key
                if (!loadApiKey()) {
                    showApiKeyModal();
                }
                
                await loadInterview();
            } else {
                window.location.href = 'login.html';
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateTranslations();
            
            // Check for browser support
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                document.querySelector('.speech-controls').style.display = 'none';
            }
            
            // Prevent accidental page refresh
            window.addEventListener('beforeunload', function(e) {
                if (interviewData && interviewData.status !== 'completed') {
                    e.preventDefault();
                    e.returnValue = 'Are you sure you want to leave? Your progress will be lost.';
                }
            });

            // Auto-save functionality
            let autoSaveTimeout;
            document.getElementById('answerTextarea').addEventListener('input', function() {
                clearTimeout(autoSaveTimeout);
                autoSaveTimeout = setTimeout(() => {
                    const answer = this.value.trim();
                    if (answer && currentUser && interviewId) {
                        // Auto-save draft
                        localStorage.setItem(`draft_${interviewId}_${currentQuestionIndex}`, answer);
                        logAction('auto_save_draft', { questionIndex: currentQuestionIndex });
                    }
                }, 2000);
            });

            // Load draft if available
            const loadDraft = () => {
                if (currentUser && interviewId && currentQuestionIndex !== undefined) {
                    const draft = localStorage.getItem(`draft_${interviewId}_${currentQuestionIndex}`);
                    if (draft) {
                        document.getElementById('answerTextarea').value = draft;
                        enableNextButton();
                    }
                }
            };

            // Load draft when question changes
            const originalDisplayCurrentQuestion = displayCurrentQuestion;
            displayCurrentQuestion = function() {
                originalDisplayCurrentQuestion.call(this);
                setTimeout(loadDraft, 100);
            };
        });

        // Unit Tests
        function runUnitTests() {
            console.log('Running unit tests...');
            
            const tests = [
                {
                    name: 'Translation function',
                    test: () => getTranslation('interview_title') === 'Technical Interview'
                },
                {
                    name: 'Timer format',
                    test: () => {
                        const timeElement = document.getElementById('timeElapsed');
                        return timeElement && timeElement.textContent.includes(':');
                    }
                },
                {
                    name: 'Progress calculation',
                    test: () => {
                        const progress = ((1) / 5) * 100;
                        return progress === 20;
                    }
                },
                {
                    name: 'API key validation',
                    test: () => {
                        const testKey = 'test-key-123';
                        return testKey.length > 0;
                    }
                },
                {
                    name: 'Speech recognition availability',
                    test: () => {
                        return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
                    }
                }
            ];

            let passed = 0;
            let failed = 0;

            tests.forEach(test => {
                try {
                    if (test.test()) {
                        console.log(`✅ ${test.name}: PASSED`);
                        passed++;
                    } else {
                        console.log(`❌ ${test.name}: FAILED`);
                        failed++;
                    }
                } catch (error) {
                    console.log(`❌ ${test.name}: ERROR - ${error.message}`);
                    failed++;
                }
            });

            console.log(`\nTest Results: ${passed} passed, ${failed} failed`);
            
            if (failed === 0) {
                console.log('🎉 All tests passed!');
            }
        }

        // Run tests in development
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            setTimeout(runUnitTests, 2000);
        }

        // Performance monitoring
        function monitorPerformance() {
            if ('performance' in window) {
                const perfData = {
                    loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart,
                    domReady: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
                    firstPaint: performance.getEntriesByType('paint')[0]?.startTime || 0
                };
                
                logAction('performance_metrics', perfData);
            }
        }

        window.addEventListener('load', monitorPerformance);

        // Error handling
        window.addEventListener('error', function(e) {
            logAction('javascript_error', {
                message: e.message,
                filename: e.filename,
                lineno: e.lineno,
                colno: e.colno,
                stack: e.error?.stack
            });
        });

        // Unhandled promise rejection handling
        window.addEventListener('unhandledrejection', function(e) {
            logAction('unhandled_promise_rejection', {
                reason: e.reason,
                stack: e.reason?.stack
            });
        });
    </script>
</body>
</html>